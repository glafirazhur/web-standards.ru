---
title: 'Пять правил использования ARIA'
date: 2021-19-09
author: gerard-cohen
source:
    title: 'ARIA Spec for the Uninitiated: Part 1'
    url: 'https://www.deque.com/blog/aria-spec-for-the-uninitiated-part-1/'
translators:
    - glafira-zhur
editors:
    - vadim-makeev
tags:
    - html
    - a11y
preview: 'Когда сталкиваешься с необходимостью добавить доступность на сайт и начинаешь гуглить - сразу встречаешься с аббревиатурой ARIA, читаешь и воодушевленно добавляешь в код... но так делать не надо!'
---

Данная статья является вольным переводом оригинала. Я добавляю свои примеры и мысли, пишу как чувствую и ставлю смайлики :). Автор статьи сказал, что ему понравилась моя интерпретация!

Джерард занимается доступностью в Twitter и попросил поделиться с вами ссылкой на его [курсы по доступности](https://www.pluralsight.com/authors/gerard-cohen). Курсы лаконичные и очень понятные (я посмотрела по 10-тидневной бесплатной подписке).

Итак, к делу!

##Введение: Опасности, которые таит в себе ARIA

_В статье введение более содержательное, так что почитайте его хотя бы ради практики английского языка :). Я передам только несколько тезисов._

**ARIA (Accessible Rich Internet Applications)** - это набор атрибутов, который позволяет сделать наши приложения более доступтными, особенно если они написаны на JS (из моего опыта - это, например, легаси-код, где давно-давно наверстали `div`-ами, а теперь надо как-то добавить доступность, но нет доступа к HTML)

Когда вы узнаете о существовании ARIA, вы начинаете везде использовать эти атрибуты, где бы только ни захотели. Например - у вас react-компонент (типично созданный на `div`-ах), и вам нужно, чтобы скринридер начал читать его правильно, поэтому вы добавляете компоненту `role` (например, `role="button"`) и какие-то еще важные aria-атрибуты (к примеру, `aria-required`, `aria-disabled`), но забываете про клавиатуру. Ошибка тут в том, что вы мало что знаете про ARIA, поэтому вероятность упустить нечто важное крайне высока. Еще дальше выясняется, что некоторые aria-атрибуты могут не иметь поддержки на определённых платформах или сочетаниях браузер + скринридер.

Если вы хотите познакомиться с ARIA - начинайте с [официальных спецификаций](https://www.w3.org/TR/wai-aria/). Не нужно сразу читать их глубоко и полностью, но парочку секций лучше изучить. Например, самое важное, с чем следует ознакомиться в спеке - это понятие роли ([role](https://www.w3.org/TR/wai-aria/#roles)).

**Role** - это семантика вашего элемента, подсказки для ассистивных технологий о том, что можно делать с этим элементом, как его обрабатывать, как с ним взаимодействует клавиатура и т.д.

**ВАЖНО:** роли (и вообще любые aria-атрибуты) не добавляют элементам никаких стилей и поведения!

У ролей есть классификация. Например, бывают роли для виджетов, для структуры документа, для live-областей (которые как-то обновляются на бэкграунде независимо от действий пользователя: появляются уведомления, изменяются статусы). Практически для каждой роли есть свой набор обязательных aria-атрибутов. Некоторые роли нельзя использовать отдельно от родительских ролей.

Вот и пробежались по введению в статью :) Переходим к правилам!

##Пять правил использования ARIA

Если вы уже понимаете, что вынуждены как-то накручивать доступность на ваши интерфейсы, нужно следовать нескольким основным правилам. Это облегчит принятие решений при разработке приложений и конкретно виджетов.

###Правило 1: Не используйте ARIA

Читая это правило, я всегда очень радуюсь - так однозначно и бескомпромиссно оно звучит :). На практике смысл его в том, что сначала вы должны полностью положиться на HTML и использовать его семантику, и только тогда, когда вам не хватило или есть какой-то сложный составной кейс (например, аккордеон или вкладки) - тогда подключайте ARIA. Также приходится использовать эти волшебные атрибуты в уже упомянутом мной легаси, где нет доступа к HTML и можно только с помощью JS добавлять что-то к существующим тегам.

###Правило 2: Не изменяйте семантику нативных контролов

Вы уже решили писать чистый, красивый и семантичный HTML, но во время работы поняли, что везде используете таблицы для вывода простых списков. У вас есть возможность явно задать элементу роль, чтобы переопределить его семантику:

- была `table`, и скринридер говорил, что вы попали в таблицу, такой-то столбец, такая-то строка;
- вы не решились переверстывать все места и просто добавили таблице `role="list"`, ее детям - тоже расставили нужные роли;
- скринридер теперь читает это как список.

Так вот, не переопределяйте дефолтную семантику без острой необходимости! Лучше замените тег (`table` превратится в `ul`/`ol`)!

Когда мне _приходится_ менять семантику:
- если нужно спрятать лэйаут-таблицы от скринридера (чтобы он не читал, что это таблица-ячейка) - задаю `role="presentation"` для таблицы;
- если `svg` со значимой картинкой - могу задать `role="img"`;
- если это `div` в составе виджета и для него нет HTML-эквивалента (например, `tab`, `tablist`, `tabpanel`);
- иногда бывают баги, например, есть `ul > li`, и мы стилями сбрасываем визуальное представление списка (`list-style: none;`), что в Safari может вызвать удаление семантики (скринридер перестанет читать это как список). Один из лайфхаков в таком случае - снова явно определить семантику, задав `role="list"` для `ul`;
- и др.

**ВАЖНО:** если вы сейчас явно задаете вашему тегу `role` (особенно если это не `div`) - вы скорее всего неправильно используете ARIA.

###Правило 3: Все интерактивные роли должны обрабатываться с клавиатуры

Нативные контролы уже имеют свою обработку с клавиатуры, нам не надо ее добавлять. Но если у вас `div[role="button"]`, то вы обязаны узнать, что ожидается от роли с точки зрения взаимодействия с клавиатурой (в случае с кнопкой - активация по <kbd>Enter</kbd> **И** <kbd>Space</kbd>), и добавить это.

Для виджетов тоже существует свое определенное, уже привычное пользователю взаимодействие с клавиатурой (например, фокус зациклен в модальном окне и не выходит за его пределы, пока окно открыто).

**Напоминаю**, роль или любой другой aria-атрибут не добавляют никакого поведения и стилей элементам, они просто сообщают ассистивным технологиям необходимую информацию о назначении, взаимодействии, состоянии.

###Правило 4: Не используйте role="presentation" и aria-hidden="true" на видимых фокусабельных элементах

`role="presentation"` - это особенная роль. Суть в том, что она полностью убирает любую семантику с элемента и с его прямых обязательных потомков (например, если поставить `role="presentation"` на `ul` - семантика также слетит с `li`). Если задать ее интерактивному контролу - ассистивные технологии перестанут его воспринимать. Если на контрол было навешено какое-то поведение - оно сохранится, но пользователь скринридера никогда не узнает, что вообще можно сделать с этим элементом, т.к. скринридер максимум зачитает текст внутри (если текст есть).

`aria-hidden` - способ спрятать что-то от ассистивных технологий. Этот атрибут не меняет вида элемента и не убирает с него никакого поведения. Элемент по-прежнему рендерится на странице, но скринридер его больше не видит.

`aria-hidden` не стоит просто так брать и использовать, чтобы скрыть контент от скринридера. Разработчики часто вставляют его ВЕЗДЕ (на видимых элементах, на невидимых), и получается, что у разных пользователей - разная информация (зрячий видит и читает текст, который недоступен незрячему, т.к. скрыт "за ненадобностью"), и это противоречит эквивалентному доступу к контенту и функциям.

**ВАЖНО:** `aria-hidden` не работает на интерактивных элементах (`input`, `button` и др.).

###Правило 5: Все интерактивные элементы обязаны иметь доступное имя (accessible name)

Любой пользователь должен понимать, что за контрол он собирается активировать. Для этого контрол уже содержит роль - т.е. определен его тип (кнопка, поле ввода, интерактивное меню). Но типа недостаточно, нужно еще и понятное, лаконичное, уникальное имя.

Имя можно задавать разными способами в зависимости от ситуации (я знаю как минимум 4), но важно, чтобы оно было в итоге получено ассистивными технологиями (скринридеры, брайлевские клавиатуры, голосовые помощники и др.) и передано пользователю.

Нельзя забывать, что люди могут использовать ваши интерфейсы тысяча и одним разным способом. Например, в случае с лейблами, пользователь, который взаимодействует с интерфейсами речью (т.е. говорит устройству, что нужно сделать), полагается на видимое имя элемента - например, текст кнопки. Называет его, и кнопка нажимается.

Как в таком случае программно нажать кнопку, у которой нет имени (кнопку-иконку)?

Нажмется ли кнопка, если ее лейбл - это просто наложенный сверху `div` с текстом (наложили ради красивого ховер-эффекта)?

##Заключение

Вот и они, самые базовые, самые основные правила использования ARIA в интерфейсах. Даже такое стартовое их понимание очень сильно улучшит ваше отношение к той работе, которую вы делаете.

Ну и конечно же, помните, что нельзя просто так взять и накрутить доступность! Думайте о пользователе и о его удобстве, помогите ему понять, что и как у вас работает, как ему достичь цели захода на сайт (купить товар, заказать услугу, получить информацию, отправить данные).

Огромное спасибо за то, что интересуетесь доступностью! Вместе победим!
